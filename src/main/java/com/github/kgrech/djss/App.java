/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package com.github.kgrech.djss;

import static spark.Spark.exception;
import static spark.Spark.internalServerError;
import static spark.Spark.notFound;
import static spark.Spark.port;
import static spark.Spark.stop;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.github.kgrech.djss.controller.AccountController;
import com.github.kgrech.djss.controller.TransferController;
import com.github.kgrech.djss.exception.NotFoundException;
import com.github.kgrech.djss.service.DSLContextProvider;
import com.github.kgrech.djss.service.ProcessingService;
import com.github.kgrech.djss.view.Message;
import java.io.IOException;
import java.io.InputStream;
import java.util.Arrays;
import java.util.List;
import java.util.Properties;
import java.util.function.Consumer;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import org.jooq.DSLContext;
import org.jooq.exception.DataAccessException;
import spark.Response;

@Slf4j
@Getter
public class App implements AutoCloseable {

    private static final String DELAY_KEY = "processing.delay";
    private static final String BATCH_KEY = "processing.batch";
    private static final String THREADS_KEY = "processing.threads";
    private static final String QUEUE_KEY = "processing.maxQueue";
    private static final String PORT_KEY = "spark.port";

    private final Properties properties = new Properties();
    private final ObjectMapper mapper = new ObjectMapper();

    private DSLContextProvider provider;
    private DSLContext ctx;
    private ProcessingService processingService;
    private AccountController accountController;
    private TransferController transferController;

    private int maxThreads;
    private int delay;
    private int batchSize;
    private int maxQueueSize;
    private int port;

    private List<Consumer<Properties>> parsers = Arrays.asList(
            (p) -> maxThreads = props(p, THREADS_KEY, 10),
            (p) -> delay = props(p, DELAY_KEY, 10),
            (p) -> batchSize = props(p, BATCH_KEY, 10),
            (p) -> maxQueueSize = props(p, QUEUE_KEY, 10),
            (p) -> port = props(p, PORT_KEY, 8080)
    );

    public void initProperties(String propertiesFile) throws IOException {
        InputStream is  = this.getClass().getClassLoader()
                .getResourceAsStream(propertiesFile);
        properties.load(is);

        parsers.forEach(p -> p.accept(properties));
    }

    public void initDSLContext() {
        provider = new DSLContextProvider(properties);
        ctx = provider.getContext();
    }

    public void initProcessingService() {
        processingService = new ProcessingService(delay, maxThreads,
                batchSize, maxQueueSize, ctx);
    }

    public void initSpark() {
        port(port);

        internalServerError((req, res) ->
                statusMessage(res, 500, "Internal Server Error"));
        notFound((req, res) ->
                statusMessage(res, 404, "Not Found"));

        exception(DataAccessException.class, (e, req, res) ->
                statusMessage(res, 400, "Illegal operation!"));
        exception(NotFoundException.class, (e, req, res) ->
                statusMessage(res, 404, e.getMessage()));
        exception(IllegalArgumentException.class, (e, req, res) ->
                statusMessage(res, 400, "Bad request: " + e.getMessage()));
        exception(UnsupportedOperationException.class, (e, req, res) ->
                statusMessage(res, 400, e.getMessage()));

        accountController = new AccountController(ctx);
        accountController.init();
        transferController = new TransferController(ctx);
        transferController.init();
    }

    public void init(String propertiesFile) throws IOException {
        initProperties(propertiesFile);
        initDSLContext();
        initSpark();
        initProcessingService();
    }

    public void close() {
        if (processingService != null) {
            processingService.close();
        }
        if (accountController != null) {
            stop();
        }
    }

    private String statusMessage(Response res,
                                int status, String message) {
        res.type("application/json");
        res.status(status);
        try {
            return mapper.writeValueAsString(new Message(message));
        } catch (JsonProcessingException e) {
            log.error("Can't serialize error message", e);
            return "";
        }
    }

    private int props(Properties properties, String name,
                            int defaultValue) {
        String strValue = properties.getProperty(name);
        if (strValue != null) {
            try {
                return Integer.valueOf(strValue);
            } catch (NumberFormatException e) {
                log.warn("Can't convert {} to number", strValue, e);
            }
        }
        log.warn("Missing property {}, using default value of {}", name,
                defaultValue);
        return defaultValue;
    }


    public static void main(String[] args) throws IOException {
        App app = new App();
        app.init("config.properties");
    }
}
